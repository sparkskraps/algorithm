/***********************************
 *       Binary Search Tree        *
 * ********************************/
#include <iostream>
#include <queue>

template <typename Key, typename Value>
class Bst
{
	public:
		Bst()
		  : pRootNode(NULL)
		{
		}

		typedef struct Node
		{
			Node() = default;
			Node(const Key &k, const Value &v)
			  : m_key(k), m_value(v)
			{
			}
			Key m_key;
			Value m_value;
			struct Node *lChild;
			struct Node *rChild;
		}Node;

		void add_to_bst(const Key &k, const Value &v)
		{
			Node *newNode = new Node(k, v);
			pRootNode = add_to_bst(pRootNode, newNode);
		}

		int get_value_by_key(const Key &k, int *value)
		{
			if(value == NULL)
				return -1;
			Node *pNode = get_value_by_key(pRootNode, k);
			if(NULL == pNode)
				return -1;
			*value = pNode->m_value;
			return 0;
		}

		void print_tree_by_bfs()
		{
			if(NULL == pRootNode)
				return;

			m_queue.push(pRootNode);	
			while(!m_queue.empty())
			{
				Node *pTmpNode = m_queue.front();
			    m_queue.pop();
				std::cout << pTmpNode->m_value << " ";
			    if(pTmpNode->lChild)
					m_queue.push(pTmpNode->lChild);
			    if(pTmpNode->rChild)
					m_queue.push(pTmpNode->rChild);
			}
			std::cout << "\n";
		}

	protected:
		Node *add_to_bst(Node *pRootNode, Node *pNewNode)
		{
			if(NULL == pRootNode)
			{
				pRootNode = pNewNode;
				pRootNode->lChild = NULL;
				pRootNode->rChild = NULL;
				// std::cout << "fuck1\n";
				return pRootNode;
			}
			if(pNewNode->m_key < pRootNode->m_key)
			{
				pRootNode->lChild = add_to_bst(pRootNode->lChild, pNewNode);
			}
			else if(pNewNode->m_key > pRootNode->m_key)
			{
				pRootNode->rChild = add_to_bst(pRootNode->rChild, pNewNode);
			}
			else
			{
				pRootNode->m_value += 1;
			}

			return pRootNode;
		}

		Node *get_value_by_key(Node *pNode, const Key &k)
		{
			if(pNode == NULL)
				return NULL;

			if(pNode->m_key < k)
			{
				return get_value_by_key(pNode->rChild, k);
			}
			else if(pNode->m_key > k)
			{
				return get_value_by_key(pNode->lChild, k);
			}
			else
			{
				return pNode;
			}
		}

	private:
		Node *pRootNode;
		std::queue<Node *> m_queue;
};

int main()
{
	Bst<int, int> bstTree;
	bstTree.add_to_bst(4, 5);
	bstTree.add_to_bst(0, 4);
	bstTree.add_to_bst(3, 7);
	bstTree.add_to_bst(2, 6);
	bstTree.add_to_bst(4, 9);
	bstTree.add_to_bst(6, 2);

	bstTree.print_tree_by_bfs();

	int value;
	int res = bstTree.get_value_by_key(2, &value);
	if(0 == res)
		std::cout << value << "\n";
	else
		std::cout << "not found\n";

	res = bstTree.get_value_by_key(7, &value);
	if(0 == res)
		std::cout << value << "\n";
	else
		std::cout << "not found\n";

	return 0;
}
